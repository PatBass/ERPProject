<?php

namespace KGC\UserBundle\Repository;

use Doctrine\ORM\EntityRepository;
use KGC\RdvBundle\Entity\ActionSuivi;
use KGC\RdvBundle\Entity\Dossier;
use KGC\RdvBundle\Entity\Encaissement;
use KGC\RdvBundle\Entity\Etat;
use KGC\RdvBundle\Entity\Support;
use KGC\UserBundle\Entity\Profil;
use KGC\UserBundle\Entity\Utilisateur;
use JMS\DiExtraBundle\Annotation as DI;
use Doctrine\ORM\Mapping\ClassMetadata;

/**
 * UserRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 * @DI\Service("kgc.utilisateur.repository")
 */
class UtilisateurRepository extends EntityRepository
{
    /**
     * @param \Doctrine\ORM\EntityManager $em
     * @param ClassMetadata               $class
     *
     * @DI\InjectParams({
     *      "em" = @DI\Inject("doctrine.orm.entity_manager"),
     *      "class" = @DI\Inject("kgc.utilisateur.repository.classmetadata"),
     * })
     */
    public function __construct($em, ClassMetadata $class)
    {
        $this->_entityName = $class->name;
        $this->_em = $em;
        $this->_class = $class;
    }

    /**
     * @param bool $actif
     *
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function findAllQB($actif = false, $activedate = null)
    {
        $qb = $this->createQueryBuilder('u')
            ->select(['u', 'mp', 'p'])
            ->innerJoin('u.mainProfil', 'mp')
            ->leftJoin('u.profils', 'p')
            ->addOrderBy('u.username', 'ASC')
        ;
        if ($actif === true) {
            if ($activedate === null) {
                $activedate = new \DateTime();
            }
            $qb = $this->addActiveCriteria($qb, $activedate);
        }

        return $qb;
    }

    /**
     * @param bool $actif
     *
     * @return array
     */
    public function findAllProprioQB($actif = false, $activedate = null)
    {
        $qb = $this->findAllQB($actif)
            ->andWhere('mp.role != :pro_voyant')
            ->setParameter('pro_voyant', Profil::VOYANT)
        ;
        if ($actif === true) {
            if ($activedate === null) {
                $activedate = new \DateTime();
            }
            $qb = $this->addActiveCriteria($qb, $activedate);
        }

        return $qb;
    }

    /**
     * @param bool $actif
     *
     * @return array
     */
    public function findAll($actif = false, $activedate = null)
    {
        $qb = $this->findAllQB($actif, $activedate);

        return $qb->getQuery()->getResult();
    }

    /**
     * Essaie de trouver l'utilisateur d'aprÃ¨s son username avec une certaine marge d'erreur sur l'orthographe.
     *
     * @param $username
     *
     * @return bool
     */
    public function getApproxi($username)
    {
        $util_list = $this->findAll();
        $find = false;
        $i = 0;
        while ($i < count($util_list) && !$find) {
            $similarity_pct = 0;
            $test = strtoupper($util_list[$i]->getUsername());
            similar_text(strtoupper($username), $test, $similarity_pct);
            if (number_format($similarity_pct) > 90) {
                $find = $util_list[$i];
            }
            ++$i;
        }

        return $find;
    }

    /**
     * @param $mainProfil
     *
     * @return array
     */
    public function findAllByMainProfilQB($mainProfil, $actif = false, $activedate = null)
    {
        $qb = $this->createQueryBuilder('u')
            ->innerJoin('u.mainProfil', 'mp')
            ->andWhere('mp.role = :main_profil')
            ->setParameter('main_profil', $mainProfil)
            ->addOrderBy('u.username', 'ASC')
        ;
        if ($actif === true) {
            if ($activedate === null) {
                $activedate = new \DateTime();
            }
            $qb = $this->addActiveCriteria($qb, $activedate);
        }

        return $qb;
    }

    /**
     * @param $mainProfil
     *
     * @return array
     */
    public function findAllByMainProfil($mainProfil, $actif = false, $activedate = null)
    {
        $qb = $this->findAllByMainProfilQB($mainProfil, $actif, $activedate);

        return $qb->getQuery()->getResult();
    }

    /**
     * @param bool $actif
     *
     * @return mixed
     */
    public function findAllVoyants($actif = false, $activedate = null)
    {
        $qb = $this->findAllByMainProfilQB(Profil::VOYANT, $actif, $activedate);

        return $qb->getQuery()->getResult();
    }

    /**
     * @param QueryBuilder $qb
     * @param \DateTime    $active_date
     *
     * @return QueryBuilder
     */
    private function addActiveCriteria($qb, \DateTime $active_date)
    {
        $qb->andWhere('u.actif = 1 OR (u.actif = 0 AND u.disabled_date > :date_rdv)')
           ->setParameter('date_rdv', $active_date);

        return $qb;
    }

    /**
     * Find all Utilisateur availables for chat
     * Join on ChatType (max_client) and current ChatParticipant to know if a user can handle more rooms or not.
     *
     * @param $canConverse
     *
     * @return array
     */
    public function findAvailableUsersForChat($includeBusy = false)
    {
        if (!$includeBusy) {
            $fields = ['u', 'chatType', 'COUNT(chatParticipants) AS HIDDEN nbChats'];
        } else {
            $fields = ['u', 'chatType', 'COUNT(chatParticipants) AS nbChats'];
        }

        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select($fields)
            ->from('KGC\UserBundle\Entity\Utilisateur', 'u')
            ->join('u.chatType', 'chatType')
            ->leftJoin('u.chatParticipants', 'chatParticipants', 'WITH', 'chatParticipants.leaveDate IS NULL')
            ->where('u.actif = 1')
            ->andWhere('u.isChatAvailable = 1')
            ->groupBy('u.id');

        if (!$includeBusy) {
            $qb->having('nbChats < chatType.maxClient');
        }

        $qb->orderBy('nbChats', 'ASC');

        return $qb->getQuery()->getResult();
    }

    public function getClientPsychicsQueryBuilder()
    {
        return $this->createQueryBuilder('u')
            //->join('u.mainProfil', 'p')
            ->where('u.chatType IS NOT NULL')
            ->orderBy('u.username');
    }

    public function getClientPsychicsForSearch()
    {
        $rows = $this->getClientPsychicsQueryBuilder()
            ->getQuery()
            ->getResult();

        $results = [];
        foreach ($rows as $utilisateur) {
            $results['#'.$utilisateur->getId().'#'] = $utilisateur->getUsername();
        }

        return $results;
    }

    public function getTMC(Utilisateur $user)
    {
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('AVG(t.temps)')
            ->from('KGCRdvBundle:RDV', 'rdv')
            ->join('rdv.tarification', 't')
            ->leftJoin('rdv.etat', 'etat')
            ->where('rdv.etat IS NOT NULL AND etat.idcode != :e_cancelled_code AND t.montant_total > 0 and t.temps >= 10')
            ->andWhere('rdv.priseencharge = 1 AND rdv.miserelation IS NOT NULL AND rdv.consultant = :user')
            ->setParameter('e_cancelled_code', Etat::CANCELLED)
            ->setParameter('user', $user);
        $result = $qb->getQuery()->getSingleScalarResult();
        return round($result, 2);
    }

    public function getMoyenne(Utilisateur $user)
    {
        $begin = new \DateTime('first day of this month');
        $end = new \DateTime('last day of this month');
        $subQuery = $this->_em->createQueryBuilder()
            ->select('max(h.date)')
            ->from('KGCRdvBundle:SuiviRdv', 'h', null)
            ->innerJoin('h.mainaction', 'ma')
            ->andWhere('ma.idcode = :take_code')
            ->andWhere('h.rdv = rdv.id')
            ->getDQL()
        ;
        $qb = $this->getEntityManager()->createQueryBuilder()
            ->select('sum(t.montant_total / 100) as billing_rea, COUNT(rdv.id) as billing_count')
            ->from('KGCRdvBundle:RDV', 'rdv')
            ->innerJoin('rdv.tarification', 't')
            ->innerJoin('rdv.support', 'support')
            ->innerJoin('rdv.historique', 'historique')
            ->leftJoin('rdv.website', 'rdv_website')
            ->leftJoin('rdv.source', 'rdv_source')
            ->leftJoin('rdv.form_url', 'rdv_url')
            ->leftJoin('rdv.codepromo', 'rdv_codepromo')
            ->leftJoin('rdv.support', 'rdv_support')
            ->leftJoin('rdv.consultant', 'rdv_consultant')
            ->innerJoin('historique.mainaction', 'mainaction')
            ->where('rdv.etat IS NOT NULL AND etat.idcode != :e_cancelled_code AND rdv.miserelation IS NOT NULL AND (cla.idcode IS NULL OR cla.idcode != :cla_dixmin)')
            ->andWhere('support.idcode != :support_code OR support.idcode IS NULL')
            ->andWhere('historique.date >= :begin_done AND historique.date < :end_done')
            ->andWhere('mainaction.idcode = :take_code')
            ->andWhere('historique.date = ('.$subQuery.')')
            ->andWhere('rdv.consultant IN (:consultant_ids)')

            ->leftJoin('rdv.etat', 'etat')
            ->leftJoin('rdv.classement', 'cla')

            ->setParameter('cla_dixmin', Dossier::DIXMIN)
            ->setParameter('e_cancelled_code', Etat::CANCELLED)
            ->setParameter('support_code', Support::SUIVI_CLIENT)
            ->setParameter('end_done', $end)
            ->setParameter('begin_done', $begin)
            ->setParameter('take_code', ActionSuivi::TAKE_CONSULT)
            ->setParameter('consultant_ids', $user->getId())

            ->addGroupBy('rdv.consultant')
        ;

        foreach ($qb->getQuery()->getArrayResult() as $result){
            $rea_ca = $result['billing_rea'];
            $rea_count = $result['billing_count'];
            return round($rea_count == 0 ? 0 : $rea_ca /  $rea_count, 2);
        }
        return 0;
    }

    public function findAllChatPsychics()
    {
        return $this->findAllByMainProfilQB(Profil::VOYANT, true)
            ->andWhere('u.chatType IS NOT NULL')
            ->orderBy('u.username', 'ASC');
    }
}
